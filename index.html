<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Interactive Graphics  -  Final Project</title>
		<link rel="stylesheet" href="style/style.css">

        <meta name="description"   content="Interactive Graphics  -  Final Project - 2019">
        <meta name="keywords"      content="HTML, CSS, JavaScript, GLSL">
        <meta name="author"        content="JohnnyMDA">        
        <meta name="viewport"      content="width=device-width, initial-scale=1.0">
        <link rel="shortcut icon"  href="img/ig_cube.ico">

        <link href="https://fonts.googleapis.com/css?family=Droid+Serif:400,400i,700|PT+Serif:400,400i&subset=latin-ext" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="style/style.css">
		<link href='style/player-style/styles.css' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" href="style/player-style/font-awesome-4.3.0/css/font-awesome.min.css">

		<script src="Common/jquery-3.4.0.min.js"></script>
		<script src="Common/general_purpose_scripts.js"></script>

		<script src="Common/three.min.js"></script>
		<script src="Common/Stats.js"></script>		<!-- JavaScript Performance Monitor -->
		
	</head>
	
	<body>
		
		<!-- Player Container -->
		<div id="container" class="disabled">

			<div id="cover-art">
				<div id="animate"></div>
			</div>


			<div id="wave"></div>


			<div id="control-bar">
				<div class="player-control">
					<div id="previous-button" title="Previous"><i class="fa fa-fast-backward"></i></div>
					<div id="play-button" title="Play"><i class="fa fa-play"></i></div>
					<div id="pause-button" title="Pause"><i class="fa fa-pause"></i></div>
					<div id="stop-button" title="Stop"><i class="fa fa-stop"></i></div>
					<div id="next-button" title="Next"><i class="fa fa-fast-forward"></i></div>
					<div id="shuffle-button" title="Shuffle Off"><i class="fa fa-random"></i></div>
					<div id="repeat-button" title="Repeat Off"><i class="fa fa-refresh"><span>1</span></i></div>
				</div>

				<div id="playlist">
					<div id="track-details" title="Show playlist">
						<i class="fa fa-sort"></i>
						<p id="track-desc">There are no tracks loaded in the player. Drag and Drop some from your PC  or  wait for loading the default ones.</p>
						<p id="track-time">
							<span id="current">-</span> / <span id="total">-</span>
						</p>
					</div>

					<div id="expand-bar" class="hidden">
<!-- 						<form>
							<label for="searchBox">Search</label><div><input id="searchBox" type="search" name="search"></div>
						</form> -->

						<ul id="list"></ul>
					</div>
				</div>
			</div>  <!-- END control-bar -->


			<div id="drop-zone" class="hidden">Drag &amp; Drop Audio Files Here</div>

		</div>


		<!-- Web Audio Player SCRIPTS -->
		<script src="Common/id3-minimized.js">	  	</script>
		<script src="Common/wavesurfer.min.js">	  	</script>
		<script src="Common/player_script.js">	  	</script>

		
		<!-- MAIN visualization SCRIPT -->
		<script>
			// set variables

			var display,

				clock 	= new THREE.Clock(),
			    
			    stats,
		
			    renderer,

			    scene,
			    sceneHeight,
			    sceneWidth,

			    camera,
			    cameraFar,
			    cameraNear,
			    cameraAspect,
			    cameraViewAngle,
			    cameraRotationSpeed  = 0.023,

			    sphere,
			    radius 		= 100,
				rings 		= 64,
				segments	= 8,

				numWaves 	= segments,
				waves 		= [],

			    cubes,
			    numCubes,

				particles_systems = [],

				analyser,
			    numChannels,
			    tdd,				// Time Domain Data;
			    fft,				// Frequency Domain Data (from Fast Fourier Transform);
			    peaks,
			    fftSize  = 2*segments * 2*rings, 	// Powers of 2 (default --> 2048) (lower --> faster) 
			    									// We use one array's spot for each cube on the sphere;
			    smoothingTimeConstantFFT  = 0.0,

			    audio_path = "audio/",
			    audio_list = ["Bob Marley - Don't worry be happy.mp3", "Aloe Blacc - I Need a Dollar.mp3", "R.E.M. - Losing My Religion.mp3", "Radiohead - Creep.mp3", "Gun N' Roses - Sweet Child O' Mine.mp3", "Jeff Buckley - Hallelujah.mp3", "Jhon Lennon - Imagine.mp3"]; 
			    			// ["AC I DC - Highway to Hell.mp3", "Aloe Blacc - I Need a Dollar.mp3", "Ben E. King - Stand By Me.mp3", "Bob Marley - Don't worry be happy.mp3", "Chuck Berry - Johnny B Goode.mp3", "Elvis Presley - Heartbreak Hotel.mp3", "Gnarls Barkley - Crazy.mp3", "Gun N' Roses - Sweet Child O' Mine.mp3", "Jeff Buckley - Hallelujah.mp3", "Jhon Lennon - Imagine.mp3", "Me & My Toothbrush - Push the Tempo.mp3", "Michael Jackson - Billie Jean.mp3", "Nirvana - Smells Like Teen Spirit.mp3", "Pink Floyd - Another brick in the wall.mp3", "Queen - Under Pressure.mp3", "R.E.M. - Losing My Religion.mp3", "Radiohead - Creep.mp3", "Ray Charles - Hit the Road Jack.mp3", "The Animals - The House of the Rising Sun.mp3", "The Eagles - Hotel California.mp3", "The Police - Every Breath You Take.mp3", "The Who - My Generation.mp3"];  // default songs list to be loaded //

			    

			// Initialize the visualization
			window.onload=function()
			{
  				init();
			}


			function init()
			{
				// enable THREE.js logs
				// console.log(THREE);
				
				// Load the default songs in the playlist
				createDefaultPlaylist(audio_path, audio_list);

				// Get the DOM element where to display
				display = document.getElementById("animate"); 

				// Set up the scene dimensions
				sceneHeight = window.innerHeight;
				sceneWidth 	= window.innerWidth;

				// Set the camera properties
				cameraFar		= 10000;
				cameraNear		= 0.1;
				cameraAspect	= sceneWidth / sceneHeight;
				cameraViewAngle	= 65;

				// Create the renderer and camera (the WebGL one)s
				renderer 	= new THREE.WebGLRenderer( { 
					antialias      	: true, 	// default false
					alpha 			: false,	// default false
					depth 			: true, 	// default true
					powerPreference	: 'high-performance',
					physicallyCorrectLights : true
				} );

				camera 		= new THREE.PerspectiveCamera(
												cameraViewAngle, 
												cameraAspect, 
												cameraNear, 
												cameraFar
											);

				// Set the Camera position (initial)
				camera.position.z = 540;		// move backward

				// START the (WebGL) renderer
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( sceneWidth, sceneHeight );

				// Append the renderer DOM element on 'display'
				display.appendChild( renderer.domElement );


				// Create the scene
				scene 	  = new THREE.Scene();

				// Set the scene's background color
				//scene.background = new THREE.Color( '#FCFCFC' );

				// add some fog in the scene (black fog)
				scene.fog = new THREE.FogExp2( 0x000000 , 0.00075 );


				//#########################//
				//#### 	   STATS.js    ####// 
				//#########################//				
					// set up the Stats.js for statistic display 
					// and add them to the DOM
					stats = new Stats();
					stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
					stats.dom.style.top 	= '10px';
					stats.dom.style.left 	= '10px';
					document.body.appendChild( stats.dom );



				// Create the (main) sphere
				createSphere();

				// Call the animate() routine
				animate();



				//#########################//
				//#### EVENT LISTENERS ####// 
				//#########################//
					// Update the scene on window resize dynamically
					window.addEventListener("resize", function()
					{
						// Set up the scene dimensions
						sceneHeight 	= window.innerHeight;
						sceneWidth 		= window.innerWidth;

						camera.aspect 	= sceneWidth / sceneHeight;
					    camera.updateProjectionMatrix();

					    renderer.setSize(sceneWidth, sceneHeight);
					    renderer.render( scene, camera );
						console.log("DEBUG: window resized !\n");
					});


					// Keyboard Controls event listener (on key down) 
					document.addEventListener("keydown", setupKeyControls);


					// computational resources optimization when out of view 
					// document.addEventListener('visibilitychange', function()
						// {
						// 	if (document.hidden)
						// 	{
						// 		// stop rendering  &&  stop audio
						// 		wavesurfer.pause();
						// 	}else{
						// 		// resume rendering  &&  audio
						// 		wavesurfer.play();
						// 	}
						// });


					// 'audioprocess' event fires continuously as the audio plays. Also fires on seeking.
					wavesurfer.on('audioprocess', function(e) {
						// update the 'fft' and 'tdd' arrays
						analyser.getByteFrequencyData(	fft  );
						analyser.getByteTimeDomainData(	tdd );

						// update the peaks array
						onAudioAvailable();		// console.log("\nDEBUG:\n\nfft \t= " + fft + "\n\npeaks \t= " + peaks + "\n\ntdd \t= " + tdd + "\n\n");

					});


				// Creates and adds a set of lines (splineCurves) to the main sphere
				//      reproducing the Time Domain Data of the audio ('tdd').
				function createLines(numWaves)
				{
					var nextAngle 	= 0,
						deltaPhi 	= 2*Math.PI / segments,
						tdd_size 	= tdd.length,
						pickRate    = 32,
						delta_x		= (2*radius + 6) / tdd_size * pickRate;

					for (var j = 0; j < segments; j++)
					{
						var splineCurve,
							linePoints,
							curvePoints	= [],
							x_pos		= 0 - radius - 3; 			// sphere centered in (0, 0, 0)	

						

						for (var i = tdd_size - 1; i >= 0; i -= pickRate)
						{
							curvePoints.push(new THREE.Vector2( x_pos , 10*Math.random()-5));
							x_pos += delta_x;				
						} console.log("curvePoints.length = " + curvePoints.length);
						
						splineCurve = new THREE.SplineCurve( curvePoints );

						linePoints 	= splineCurve.getPoints( tdd_size * 10 );

						var waveGeometry = new THREE.BufferGeometry().setFromPoints( linePoints );
						var waveMaterial = new THREE.LineBasicMaterial( { color : 0xff0000 } );

						// Create the final object to add to the scene
						var wave = new THREE.Line( waveGeometry, waveMaterial );

						// Put it on the correct axis
						wave.rotateZ( Math.PI / 2 );
						wave.rotateX(  nextAngle  );


						waves.push(wave);
						//console.log("waves[j].points = " + wave.geometry.vertices;

						sphere.add(wave);

						// Get the next angle
						nextAngle += deltaPhi;
					}
				};



				// Creates the main sphere //
				function createSphere() 
				{
					var sphereFaces,
						sphereMaterial,

						cubeSize 		= 8,
						  cube_L_coef     = 1.6,
						  cube_l_coef 	  = 0.5,
						  cube_h_coef     = 0.85,

						cubeHalfSize 	= cubeSize / 2,

						spaceRangePS	= 1000;

					//#########################//
					//###### MAIN SPHERE ######//
					//#########################//
					sphere = new THREE.Mesh( 
									new THREE.SphereGeometry( radius, segments, rings), 
									new THREE.MeshNormalMaterial({
											wireframe   : true,
											flatShading	: true, 
											transparent	: true,  
											opacity    	: 0.023
										})
										    							// we don't want to see it
								 );

					// Add the sphere to the scene
					scene.add(sphere);



					//###################//
					//###### CUBES ######//
					//###################//
					
					// Get the faces of the sphere
					sphereFaces	= sphere.geometry.faces;

					// New cubes array
					cubes = [];

					// Loop through every sphere's face
					var cube, sphereFace, vertices, scaleVector, faceCentroid;
					for (var i=0, len=sphereFaces.length; i < len; i++) 
					{
						// Get the i-th sphere's face
						sphereFace = sphereFaces[i];

						// Create the i-th cube
						cube = 	new THREE.Mesh(
									new THREE.BoxGeometry(cube_L_coef * cubeSize, cube_l_coef * cubeSize, cube_h_coef * cubeSize),
									new THREE.MeshNormalMaterial({
											wireframe   : false,
											flatShading	: true,  
											transparent	: true,  
											opacity    	: 0.68
									})
								);

						// Get the cube vertexes (corners)
						vertices = cube.geometry.vertices;
						for (var v=0; v < vertices.length; v++)
						{
							// Shift each vertex in order to e able to scale
							// the cube from the bottom rather then the center 
							vertices[v].z  -= cubeHalfSize;
						}

						// Move the v-th cube to the i-th face's center
						faceCentroid = new THREE.Vector3( 0, 0, 0 );
				            faceCentroid.add( sphere.geometry.vertices[ sphereFace.a ] );
				            faceCentroid.add( sphere.geometry.vertices[ sphereFace.b ] );
				            faceCentroid.add( sphere.geometry.vertices[ sphereFace.c ] );
				            
				            faceCentroid.x = (faceCentroid.x < 0)  ?  faceCentroid.x - 5  :  faceCentroid.x + 5;
							faceCentroid.y = (faceCentroid.y < 0)  ?  faceCentroid.y - 5  :  faceCentroid.y + 5;
							faceCentroid.z = (faceCentroid.z < 0)  ?  faceCentroid.z - 5  :  faceCentroid.z + 5;
				            
				            faceCentroid.divideScalar( 3 );

						cube.position.x = faceCentroid.x;
						cube.position.y = faceCentroid.y;
						cube.position.z = faceCentroid.z;

						// Scale the cube so it's smaller near the poles of the sphere (visual effect)
						scaleValue 		= Math.abs(cube.position.y) / (radius);
						cube.scale.x 	= 1 - (scaleValue * 0.7);
						cube.scale.y 	= 1 - (scaleValue * 0.7);
						cube.scale.z 	= 1 - (scaleValue * 0.7);

						cube.scaleValue = 1 - (scaleValue * 0.7);

						// Make the cube look at the center of the sphere
						cube.lookAt(sphere.position);

						// Push the new cube in the cubes' array
						cubes.push(cube);

						// Add the new cube to the scene
						sphere.add(cube);
					};
					numCubes = cubes.length;


					//#########################//
					//#### PARTICLE SYSTEM ####//
					//#########################//

					var v,
						color,
						size, 
						particles,
						particleGeometry,
						numParticles			  = 1400,  					// x 7  (final number)(different properties)
						materials 				  = [],
						particlesParamsCollection = [// [hex color, size] 	//	
														[0xA31621, 3.05],	// red
														[0x3CB371, 3.15],	// green
														[0x235686, 3.55],	// blue

														[0xfefefe, 2.70],	// white
													
														[0xA31621, 2.05],	// red
														[0x3CB371, 2.25],	// green
														[0x235686, 2.65]	// blue
													];

					// New geometry for the particles
					particleGeometry = new THREE.Geometry();

					// Create and add the particles' vectors to the geometry
					var rand_x, rand_y, rand_z, no_particle_space = 1.0 * camera.position.z;
					for (var i=0; i < numParticles; i++) 
					{
						do {
							// at least one out of three needs to be greater then  | no_particle_space |
							rand_x = randomRangeNumber( randomOutOfTwo(0, no_particle_space),  spaceRangePS ) * randomOutOfTwo(-1, 1);
							rand_y = randomRangeNumber( randomOutOfTwo(0, no_particle_space),  spaceRangePS ) * randomOutOfTwo(-1, 1);
							rand_z = randomRangeNumber( randomOutOfTwo(0, no_particle_space),  spaceRangePS ) * randomOutOfTwo(-1, 1);														
						} 	// rarely is doing more than 1-2 cycles here 
						while( (Math.abs(rand_x) < no_particle_space  &&  Math.abs(rand_y) < no_particle_space  &&  Math.abs(rand_z) < no_particle_space) );

						v = new THREE.Vector3(	rand_x, //(rand_x < 0)  ?  rand_x - no_particle_space  :  rand_x + no_particle_space,
												rand_y, //(rand_y < 0)  ?  rand_y - no_particle_space  :  rand_y + no_particle_space,
												rand_z  //(rand_z < 0)  ?  rand_z - no_particle_space  :  rand_z + no_particle_space
											);  // (random points around 0 in spaceRangePS)

						particleGeometry.vertices.push(v);
					};

					// create ONE PARTICLE SYSTEM for each [size, color] 
					for (var i=0, len=particlesParamsCollection.length; i < len; i++)
					{
						color 	= particlesParamsCollection[i][0];
						size 	= particlesParamsCollection[i][1];
						
						materials[i] = new THREE.PointsMaterial( {size : size,  sizeAttenuation : true} );
						materials[i].color.setHex(color);

						particles 	 = new THREE.Points( particleGeometry, materials[i] );

						particles.rotation.x  = randomOutOfTwo(-1, 1) * Math.random() * 1000 + (i+1);
						particles.rotation.y  = randomOutOfTwo(-1, 1) * Math.random() * 1000 + (i+1);
						particles.rotation.z  = randomOutOfTwo(-1, 1) * Math.random() * 1000 + (i+1);

						particles_systems.push(particles);

						scene.add(particles);
					};
				}; 	// --- END createSphere() --- //


				//#########################//
				//####    Audio Data   ####//
				//#########################//

				// Log wavesurfer's warnings
				wavesurfer.on('error', function(e) {
        				console.warn(e);
    			});

				// Get the wavesurfer's analyser node object
				analyser 	= wavesurfer.backend.analyser;

				// 'channelCountMode' is set to 'explicit' on an analyserNode,
				// so we can get the correct # of channels of the AudioNode in input 
				numChannels = analyser.channelCount;
				console.log("DEBUG:\nnumChannels = " + numChannels);

				// Set the FFT size (default fftSize=2048)(powers of 2)
				//         (fft scale to one channel size)
				analyser.fftSize = fftSize * numChannels;

				// Tune up the power value in the scaling range for the FFT analysis data
					// analyser.minDecibels = -100;  // Where 0dB is the loudest possible sound, (-10 dB is a 10th of that). 
					// analyser.maxDecibels = -30;   // The default value is (-100dB for min)  and  (-30dB for max).		
				analyser.smoothingTimeConstant = smoothingTimeConstantFFT; // (0 meaning no time averaging). The default value is 0.8.

				// Initialize the buffers for the Frequency and Time Domain Data:
				//     (it will be updated on 'onaudioprocess' event firing)
				fft 		= new Uint8Array(analyser.frequencyBinCount);
				tdd 		= new Uint8Array(analyser.fftSize);		// this array should be the same length as the fftSize of the analyser;

				// Array that will track smoothly the frequencies variations in time 
				// (it will be updated in onAudioAvailable() function, on 'onaudioprocess' event firing) 
				peaks 		= new Float32Array(fftSize);

				console.log("DEBUG:\n\tfft-length \t\t= " + fft.length + "\n\tpeaks-length \t= " + peaks.length + "\n\ttdd-length \t\t= " + tdd.length);


				// Run when audio data is available (after fft updates)
				function onAudioAvailable()
				{
					// Compute and get the peaks' values of the audio signal
					for (var i=0,  fft_size = fft.length; i < fft_size; i++)
					{
						// Equalizer: attenuate low frequents and boost the high ones
						//fft[i] *= -1 * Math.log((fft_size / 2 - 1.0*i) * (0.5 / fft_size / 2)) * fft_size;

						if (peaks[i] < fft[i] + 10) // to much vibration // TODOS //
						{
							// Assign a new peak value
							peaks[i] = fft[i];
						} 
						else 
						{
							// decreasing the peak slowly till a new peaks is found
							peaks[i] *= 0.96;
						}
					}
				}; // --- END onAudioAvailable() --- //


				// 'onKeyDown' events function 
			    function setupKeyControls(e) {
			    	var x = camera.position.x,
					    y = camera.position.y,
					    z = camera.position.z;

			    	switch (e.keyCode)
			        {
			          		case 37:  	//  <--  (Left)
			          			camera.position.x = x * Math.cos(cameraRotationSpeed) + z * Math.sin(cameraRotationSpeed);
    							camera.position.z = z * Math.cos(cameraRotationSpeed) - x * Math.sin(cameraRotationSpeed);
			          			break;
			          
			          		case 38: 	//   ^   (Up)
			          			camera.position.y = y * Math.cos(cameraRotationSpeed) + x * Math.sin(cameraRotationSpeed);
								camera.position.x = x * Math.cos(cameraRotationSpeed) - y * Math.sin(cameraRotationSpeed);
						        break;
			          
			          		case 39:   	//  -->  (Right)
			          			camera.position.x = x * Math.cos(cameraRotationSpeed) - z * Math.sin(cameraRotationSpeed);
								camera.position.z = z * Math.cos(cameraRotationSpeed) + x * Math.sin(cameraRotationSpeed);
								break;
			          
			          		case 40: 	// 	 v   (Down)
			          			camera.position.y = y * Math.cos(cameraRotationSpeed) - x * Math.sin(cameraRotationSpeed);
								camera.position.x = x * Math.cos(cameraRotationSpeed) + y * Math.sin(cameraRotationSpeed);
			        			break;

			        		case 107: 	//   +   (plus)
			        			cameraRotationSpeed += 0.001;
			        			break;
			        		
			        		case 109: 	//   -   (minus)
			        			cameraRotationSpeed -= 0.001;
			        			break;
			        		//default:
			        		// 	console.log("DEBUG: pressed key: " + e.keyCode);
			        		// 	break;
			        } 	// --- END switch --- //
					// Update camera and look again at the origin			        
			        camera.lookAt(scene.position);

			    }; 	// --- END setupKeyControls(e)



				//###############################//
				//####    Helper Functions   ####//
				//###############################//

				// Returns a random number between min (inclusive) and max (exclusive)
				function randomRangeNumber(min, max) {
				    return Math.random() * (max - min) + min;
				}

				// Returns on of the two arguments randomly
				function randomOutOfTwo(first, second) {
					return (Math.random() < 0.5)  ?  first  :  second;
				}

				// Set default parameters
				function setDefaultParams()
				{
					smoothingTimeConstantFFT 	= 0.0;

					numParticles 	= 1400;
					
					cubeSize 		= 8;
					cube_L_coef		= 1.6;
					cube_l_coef 	= 0.5;
					cube_h_coef		= 0.85;
				}



				// Create the lines
				createLines(numWaves);

			}; // --- END init() --- //



			function animate()
			{
				// New Animation Frame Request
				window.requestAnimationFrame(animate);


				// Call the main renderer
				render();


				// START STATS.js monitoring
				stats.update();

			};  // --- END animate() --- //


			function render()
			{
				var time = Date.now() * 0.001;
				//console.log("DEBUG:\ntime = " + time);

				if (analyser) 	// "analyser" needs to be active here ! //
				{
					// Cubes scale's update as 'fft' variates //
					var cube;
					for (var i=0, fft_size = peaks.length; i < numCubes; i++)
					{
						cube 		= cubes[i];
						fft_index 	= i % fft_size;

						// Scale the cube high as the i-th peaks amplitude (demo 1)
						cube.scale.z = cube.scaleValue + ( (peaks[fft_index])  ?  1 + (3 * (fft[fft_index] / peaks[fft_index]))  :  0);
					}


					// Lines points update as 'tdd' variates //
					if (waves[0].points)
					{
						for (var r = waves.length - 1; r >= 0; r--) {
							for (var i = waves.points.length - 1; i >= 0; i--) {
								console.log("waves.points[" + r + "] = " + waves[r].points[i]);
							}

						}					
					}


				}

				// Sphere rotation (all the hierarchical structure of the sphere will rotate)
				sphere.rotation.x     = 0.7 * Math.sin(0.45 * time) + 1.72;
				sphere.rotation.y     = 0.6 * Math.sin(0.35 * time) + 2.31;
				sphere.rotation.z     = 0.5 * Math.cos(0.15 * time) + 1.57;

				// Sphere opacity fading in/out periodically
				//	('abs' -> avoid the full opacity fading)
				// sphere.material.opacity = Math.abs(0.15 * (1 + Math.sin( clock.getElapsedTime() ) ) - 0.35) + 0.05;


				// Particle systems' rotation
				for (var i = particles_systems.length - 1; i >= 0; i--) {
					particles_systems[i].rotation.x  = 0.57 * Math.cos(0.23 * time) + 0.11 * (i+1);
					particles_systems[i].rotation.y  = 0.55 * Math.cos(0.24 * time) + 0.12 * (i+1);
					particles_systems[i].rotation.z  = 0.53 * Math.sin(0.21 * time) + 0.13 * (i+1); 
				}


				// Render the scene
				renderer.render(scene, camera);
			
			} 	// --- END render() --- //

		</script>


	</body>
</html>